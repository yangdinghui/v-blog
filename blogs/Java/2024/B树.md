---
title: B-tree如何使数据查询更快？
date: 2024-03-01
tags:
 - 数据结构
categories:
 -  Java
---
#### B 树是一种有助于搜索大量数据的结构。它是 40 多年前发明的，但仍然被大多数现代数据库所采用。尽管有更新的索引结构，例如 LSM 树，但 B 树在处理大多数数据库查询时是不败的。

### 二叉搜索树 (BST)

#### 那么“B”代表什么？
据wikipedia.org报道，B 树的发明者 Edward M. McCreight 曾说过：**“你越多地思考 B 树中的 B 的含义，你就越能理解 B 树。”**   
一个简单的二叉搜索树(BST)示例     
<img src="/B/bst-basic.webp" width="30%">  
较大的数字始终位于右侧，较小的数字始终位于左侧。  
<img src="/B/bst-bigger.webp" width="50%">    
这棵树包含七个数字，但是我们最多需要访问三个节点才能找到任何数字。以下示例可视化搜索 14。我使用 SQL 定义查询，以便将这棵树视为实际的数据库索引。  
<img src="/B/bst-bigger-searching.webp" width="50%">   

### 考虑硬件存储  
从理论上讲，使用二叉搜索树来运行我们的查询看起来不错。它的时间复杂度（搜索时）与 O(logn)B 树相同。但是，在实践中，此数据结构需要在实际硬件上工作。索引必须存储在计算机上的某个位置。  
计算机有三个可以存储数据的位置：
- CPU 缓存
- RAM（内存）
- 磁盘（存储）  

#### 数据库大量使用内存 （RAM）。它有一些很大的优点：
- 确保快速随机访问（下一段将详细介绍）
- 它的大小可能非常大（例如，AWS RDS 云服务为实例提供几 TB 的可用内存）。   <br/>

#### 缺点:  
- 当电源关闭时，您将丢失数据。此外，与磁盘相比，它非常昂贵。  
最后，内存的缺点是磁盘存储的优点。它很便宜，即使我们失去电力，数据也会留在那里。但是，天下没有免费的午餐！问题是我们需要小心随机和顺序访问。从磁盘读取速度很快，但仅限于某些条件！  

### 随机和顺序访问
内存可以可视化为一行值的容器，其中每个容器都有编号  
<img src="/B/memory.webp" width="50%">  
现在，假设我们想要从容器 1、4 和 6 读取数据。它需要随机访问  
<img src="/B/memory-random-access.webp" width="50%">    
然后让我们将其与读取容器 3、4 和 5 进行比较。可以按顺序完成  
<img src="/B/memory-sequential-access.webp" width="50%">  
随机跳转”和“顺序读取”之间的区别可以根据硬盘驱动器来解释。它由磁头和圆盘组成。  
<img src="/B/hdd-disk.webp" width="50%">  
“随机跳跃”需要将磁头移动到磁盘上的给定位置。“顺序读取”只是旋转磁盘，允许磁头读取连续值。读取兆字节的数据时，这两种访问类型之间的差异是巨大的。使用“顺序读取”可显著缩短获取数据所需的时间  
Adam Jacobs在Acm Queue上发表的文章“The Pathologies of Big Data”中研究了随机访问和顺序访问之间的速度差异。它揭示了一些令人震惊的事实： 
- HDD上的顺序访问可能比随机访问快数十万倍。🤯
- 从磁盘按顺序读取可能比从内存中随机读取更快。  <br/>

现在谁甚至使用硬盘？固态硬盘呢？这项研究表明，完全按顺序读取 HDD 可能比 SSD 更快。但是，请注意，这篇文章是 2009 年的文章，SSD 在过去十年中得到了显着发展，因此这些结果可能已经过时。  
总而言之，关键的一点是，我们尽可能选择顺序访问。在下一段中，我将解释如何将其应用于我们的索引结构。

### 优化树以实现顺序访问
二叉搜索树可以以与堆相同的方式在内存中表示：
- 父节点位置为i
- 左节点位置是2i
- 正确的节点位置是2i+1 </br>
以下是根据示例计算这些位置的方式（父节点从 1 开始）   
<img src="/B/tree-representation-in-memory-1.webp" width="50%">  
根据计算出的位置，节点与内存对齐  
<img src="/B/tree-representation-in-memory-2.webp" width="50%">    
你还记得几章前可视化的查询吗？    
<img src="/B/bst-bigger-searching.webp" width="50%">  
这就是它在内存级别上的样子   
<img src="/B/tree-representation-in-memory-query.webp" width="50%">  
执行查询时，需要访问内存地址 1、3 和 6。访问三个节点不是问题;但是，随着我们存储的数据越来越多，树会变得更高。存储超过 100 万个值需要至少 20 个高度的树。这意味着必须从内存中不同位置读取 20 个值。它会导致完全随机的访问！  

### 页面




### 平衡




### 自平衡算法示例




### 总结










##### 注：[原文](https://blog.allegro.tech/2023/11/how-does-btree-make-your-queries-fast.html)
